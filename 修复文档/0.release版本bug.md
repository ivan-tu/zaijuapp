项目是很多年前的代码，之前使用的是uiwebview，我们已经完成了对uiwebview向wkwebview的升级。
但怀疑还有遗留的写法不支持新版ios的新特性所以导致release无法加载xcode运行版却可以。
项目通过xcode可以正确运行，但在release中运行时只能正确加载首页，点击tab和内页时页面会卡住。

请搜索xcode加载和release加载的区别补充在这：

### Xcode Debug 版本和 Release 版本的主要区别：

1. **编译优化**：
   - Debug：没有编译优化，代码按原样执行，方便调试
   - Release：启用编译优化（-O2/-Os），代码会被重排、内联，可能改变执行顺序

2. **日志和断言**：
   - Debug：NSLog、print、assert 等调试代码都会执行
   - Release：这些调试代码通常被编译器移除或禁用

3. **符号信息**：
   - Debug：包含完整的调试符号，可以看到详细的调用栈
   - Release：符号被剥离，只保留必要的符号表

4. **JavaScript 执行环境**：
   - Debug：JavaScript 错误会有详细的错误信息和调用栈
   - Release：JavaScript 错误信息被压缩，某些错误可能被静默处理

5. **文件访问权限**：
   - Debug：通过 Xcode 运行时有更宽松的文件访问权限
   - Release：严格的沙盒限制，只能访问应用自己的文档目录

6. **JavaScript Bridge 初始化时机**：
   - Debug：可能因为调试器的存在导致初始化时机略有延迟
   - Release：更快的执行速度可能导致某些异步操作的时序问题

7. **内存管理**：
   - Debug：内存不会被积极回收，方便调试
   - Release：更积极的内存回收，可能导致某些对象被提前释放


请搜素uiwebview和wkwebview的区别补充在这：

### UIWebView 和 WKWebView 的主要区别：

1. **架构差异**：
   - UIWebView：运行在应用进程内，共享应用的内存空间
   - WKWebView：运行在独立的进程中，与应用进程隔离，更安全稳定

2. **JavaScript 执行**：
   - UIWebView：同步执行 JavaScript，会阻塞主线程
   - WKWebView：异步执行 JavaScript，不会阻塞主线程

3. **JavaScript Bridge**：
   - UIWebView：使用 `stringByEvaluatingJavaScriptFromString` 同步执行
   - WKWebView：使用 `evaluateJavaScript:completionHandler:` 异步执行，需要回调处理

4. **通信机制**：
   - UIWebView：通过 URL Scheme 拦截实现 JS 到原生的通信
   - WKWebView：使用 `WKScriptMessageHandler` 消息处理机制，更高效

5. **本地文件加载**：
   - UIWebView：可以直接加载本地文件，没有限制
   - WKWebView：有安全限制，需要使用 `loadFileURL:allowingReadAccessToURL:` 指定读取权限

6. **Cookie 和存储**：
   - UIWebView：与 NSHTTPCookieStorage 共享 Cookie
   - WKWebView：独立的 Cookie 存储，需要手动同步

7. **性能差异**：
   - UIWebView：性能较差，内存占用高
   - WKWebView：性能更好，内存占用低，支持 60fps 滚动

8. **API 支持**：
   - UIWebView：iOS 2.0+，已在 iOS 12 废弃
   - WKWebView：iOS 8.0+，是苹果推荐使用的 WebView

9. **JavaScript 注入时机**：
   - UIWebView：页面加载完成后注入
   - WKWebView：可以在文档开始时注入（WKUserScriptInjectionTimeAtDocumentStart）


请了解项目通过webview加载manifest资源显示页面的逻辑补充在这（包括html、css、js、json文件是如何组合在webview中显示的）：

### WebView 加载 manifest 资源的逻辑：

1. **资源组织结构**：
   ```
   manifest/
   ├── app.html                 # 主模板，包含 {{body}} 占位符
   ├── pages/                   # 页面目录
   │   └── home/index/         # 具体页面
   │       ├── index.html      # 页面 HTML
   │       ├── index.js        # 页面脚本
   │       ├── index.css       # 页面样式
   │       └── index.json      # 页面配置（标题、组件依赖等）
   ├── static/                  # 静态资源
   │   ├── app/
   │   │   ├── template.html   # 页面通用模板
   │   │   └── webviewbridge.js # JS Bridge
   │   └── css/js/images/      # 公共资源
   └── appInfo.json            # TabBar 配置
   ```

2. **加载流程**：
   - **步骤1**：读取 `app.html` 作为主模板
   - **步骤2**：解析 URL（如 `/p/home/index/index`）到本地路径
   - **步骤3**：通过 `CustomHybridProcessor` 处理页面：
     - 读取页面的 HTML 文件
     - 读取页面的 JSON 配置（标题、组件依赖）
     - 处理 `usingComponents` 组件依赖
     - 将页面内容注入到模板
   - **步骤4**：设置 `manifest` 目录为 `baseURL`
   - **步骤5**：调用 `loadHTMLString:baseURL:` 加载最终 HTML

3. **关键代码位置**：
   - 主加载逻辑：`XZWKWebViewBaseController.m`
   - 资源处理器：`CustomHybridProcessor.m`
   - 模板路径：`[BaseFileManager appH5LocailManifesPath]`

4. **资源访问机制**：
   - 所有静态资源通过 `baseURL` 相对路径访问
   - CSS/JS 文件通过 `<link>` 和 `<script>` 标签加载
   - 图片等资源通过相对路径引用

5. **组件系统**：
   - 支持组件化开发，通过 `usingComponents` 声明依赖
   - 组件递归加载，自动处理嵌套依赖
   - 组件内容会被注入到使用它的页面中



请了解项目，把ios和js互相通信的逻辑补充在这：

### iOS 和 JavaScript 通信逻辑：

1. **桥接框架**：
   - 使用 `WKWebViewJavascriptBridge` 库实现双向通信
   - 通过 `xzBridge` 作为统一的消息通道
   - 支持异步回调机制

2. **JavaScript 到 iOS 的通信**：
   ```javascript
   // JS端调用（webviewbridge.js）
   webViewCall('action名称', {
       data: '参数',
       success: function(res) { },
       fail: function(err) { }
   });
   ```
   
   - 常用 actions：
     - `pageReady`: 页面加载完成
     - `request`: 网络请求
     - `navigateTo`: 页面跳转
     - `getLocation`: 获取位置
     - `showToast`: 显示提示
     - `payWeiXin`/`payAlipay`: 支付
     - `shareToWeiXin`: 分享
     - `selectImage`/`uploadImage`: 图片操作

3. **iOS 到 JavaScript 的通信**：
   ```objc
   // iOS端调用
   NSDictionary *callJsDic = [[HybridManager shareInstance] 
       objcCallJsWithFn:@"函数名" data:参数];
   [self objcCallJs:callJsDic];
   ```
   
   - 常用函数：
     - `pageShow`: 页面显示
     - `pagePullDownRefresh`: 下拉刷新
     - `setData`: 设置数据
     - `keyboardShow`/`keyboardHide`: 键盘事件

4. **关键实现细节**：
   - **iOS端**（XZWKWebViewBaseController.m）：
     - `setupJavaScriptBridge`: 初始化桥接
     - `jsCallObjc:jsCallBack:`: 处理JS调用
     - `objcCallJs:`: 调用JS函数
   
   - **JS端**（webviewbridge.js）：
     - `wx.app.connect()`: 初始化连接
     - `webViewCall()`: 调用原生方法
     - `bridge.registerHandler()`: 注册处理器

5. **通信流程**：
   - 页面加载 → JS执行 `wx.app.connect()` → 建立桥接
   - 桥接就绪 → JS调用 `pageReady` → iOS显示页面
   - 用户操作 → JS调用相应action → iOS处理并回调
   - iOS事件 → 调用JS函数 → JS更新界面

6. **关键时序问题**：
   - `pageReady` 必须在桥接建立后调用
   - Release版本可能因优化导致时序变化
   - 需要确保 `wx.app.connect` 在页面加载时执行


阅读完所有代码后，请把你认为有隐患、有可能导致release无法正确加载、项目无法通过App Store审核的问题补充在这：


