# Swift项目开发规范与优化建议

## 文档说明
本文档基于对原Objective-C项目的深入分析，总结了存在的问题，并为Swift新项目提供开发规范和最佳实践，确保原项目中的问题不会在新项目中重现。

## 一、原项目存在的问题

### 1.1 架构和设计问题
- **高耦合度**: MVC架构导致控制器臃肿，业务逻辑与UI混杂
- **模块化缺失**: 功能模块之间依赖混乱，难以独立测试和复用
- **单一职责违反**: 单个类承担过多职责（如CFJClientH5Controller超过2000行）

### 1.2 代码质量问题
- **过时API使用**: UIAlertView、NSURLConnection、UILocalNotification等已废弃API
- **注释代码泛滥**: 项目中存在117处注释代码，影响代码可读性
- **冗余代码**: 大量重复的版本检查、相似的功能实现
- **命名不规范**: 混用驼峰和下划线命名，缩写过多

### 1.3 内存管理问题
- **循环引用风险**: Block和delegate使用不当，缺少weak/strong dance
- **内存泄漏隐患**: WebView、定时器、通知观察者未正确释放
- **大对象管理不当**: 图片、视频等资源未及时释放

### 1.4 异步处理问题
- **回调地狱**: 多层嵌套的completion blocks
- **错误处理不一致**: 有些用NSError，有些用自定义错误码
- **线程安全问题**: UI操作未确保在主线程

### 1.5 测试和维护问题
- **测试覆盖率低**: 缺少单元测试和UI测试
- **依赖注入缺失**: 难以进行mock和测试
- **文档缺失**: 关键业务逻辑缺少文档说明

## 二、Swift项目开发规范

### 2.1 架构规范

#### 2.1.1 采用MVVM-C架构
```swift
// ViewModel示例 - 分离业务逻辑
class LoginViewModel {
    // 输入
    @Published var username = ""
    @Published var password = ""
    
    // 输出
    @Published var isLoginButtonEnabled = false
    @Published var loginState: LoginState = .idle
    
    // 依赖注入
    private let authService: AuthServiceProtocol
    private let validator: ValidatorProtocol
    
    init(authService: AuthServiceProtocol, validator: ValidatorProtocol) {
        self.authService = authService
        self.validator = validator
        setupBindings()
    }
    
    func login() async {
        loginState = .loading
        do {
            let user = try await authService.login(username: username, password: password)
            loginState = .success(user)
        } catch {
            loginState = .failure(error)
        }
    }
}
```

#### 2.1.2 模块化设计原则
```swift
// 每个模块定义清晰的接口
public protocol PaymentModuleInterface {
    func startPayment(order: Order) async throws -> PaymentResult
}

// 模块内部实现对外隐藏
internal class PaymentModuleImpl: PaymentModuleInterface {
    private let paymentService: PaymentService
    private let orderValidator: OrderValidator
    
    public func startPayment(order: Order) async throws -> PaymentResult {
        try orderValidator.validate(order)
        return try await paymentService.process(order)
    }
}
```

### 2.2 代码质量规范

#### 2.2.1 命名规范
```swift
// ✅ 良好的命名
class UserProfileViewController { }
func fetchUserProfile(userId: String) async throws -> UserProfile { }
let maximumRetryCount = 3

// ❌ 避免的命名
class UPVC { }  // 过度缩写
func getData() { }  // 不明确
let max_retry = 3  // 使用下划线
```

#### 2.2.2 错误处理规范
```swift
// 统一的错误类型
enum AppError: LocalizedError {
    case network(NetworkError)
    case validation(ValidationError)
    case business(BusinessError)
    
    var errorDescription: String? {
        switch self {
        case .network(let error):
            return error.localizedDescription
        case .validation(let error):
            return error.message
        case .business(let error):
            return error.userFriendlyMessage
        }
    }
}

// 使用Result类型或async/await
func fetchData() async throws -> Data {
    guard networkAvailable else {
        throw AppError.network(.noConnection)
    }
    return try await networkService.request(endpoint)
}
```

#### 2.2.3 避免代码冗余
```swift
// 使用协议和泛型避免重复
protocol Cacheable {
    associatedtype CacheKey: Hashable
    var cacheKey: CacheKey { get }
}

class Cache<T: Cacheable> {
    private var storage: [T.CacheKey: T] = [:]
    
    func store(_ item: T) {
        storage[item.cacheKey] = item
    }
    
    func retrieve(key: T.CacheKey) -> T? {
        return storage[key]
    }
}
```

### 2.3 内存管理规范

#### 2.3.1 避免循环引用
```swift
// 使用weak self避免循环引用
class ViewController: UIViewController {
    private var timer: Timer?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // ✅ 正确：使用weak self
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateUI()
        }
    }
    
    deinit {
        timer?.invalidate()
    }
}

// Delegate模式使用weak
protocol ViewControllerDelegate: AnyObject {
    func didTapButton()
}

class CustomView {
    weak var delegate: ViewControllerDelegate?
}
```

#### 2.3.2 资源管理
```swift
// 大资源的及时释放
class ImageProcessor {
    func processLargeImage(_ image: UIImage) -> UIImage? {
        return autoreleasepool {
            // 处理大图片时使用autoreleasepool
            let processedImage = applyFilters(to: image)
            return compressImage(processedImage)
        }
    }
}

// WebView内存管理
class WebViewController: UIViewController {
    private var webView: WKWebView?
    
    deinit {
        // 清理WebView
        webView?.stopLoading()
        webView?.configuration.userContentController.removeAllUserScripts()
        webView = nil
    }
}
```

### 2.4 异步编程规范

#### 2.4.1 使用async/await
```swift
// ✅ 推荐：使用async/await
class UserService {
    func loadUserData() async throws -> User {
        let profile = try await fetchProfile()
        let preferences = try await fetchPreferences()
        return User(profile: profile, preferences: preferences)
    }
}

// ❌ 避免：回调地狱
class OldUserService {
    func loadUserData(completion: @escaping (Result<User, Error>) -> Void) {
        fetchProfile { profileResult in
            switch profileResult {
            case .success(let profile):
                self.fetchPreferences { preferencesResult in
                    // 嵌套继续...
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
}
```

#### 2.4.2 并发处理
```swift
// 使用TaskGroup进行并发操作
func loadMultipleResources() async throws -> Resources {
    try await withThrowingTaskGroup(of: Resource.self) { group in
        group.addTask { try await self.loadResource(id: "1") }
        group.addTask { try await self.loadResource(id: "2") }
        group.addTask { try await self.loadResource(id: "3") }
        
        var resources: [Resource] = []
        for try await resource in group {
            resources.append(resource)
        }
        return Resources(items: resources)
    }
}

// Actor保证线程安全
actor DataCache {
    private var cache: [String: Data] = [:]
    
    func store(data: Data, for key: String) {
        cache[key] = data
    }
    
    func retrieve(key: String) -> Data? {
        return cache[key]
    }
}
```

### 2.5 WebView和JSBridge规范

#### 2.5.1 类型安全的JSBridge
```swift
// 定义JavaScript调用的协议
protocol JSBridgeAction: Codable {
    associatedtype Response: Codable
    var action: String { get }
}

// 具体的Action实现
struct NavigateAction: JSBridgeAction {
    struct Response: Codable {
        let success: Bool
        let message: String?
    }
    
    let action = "navigate"
    let url: String
    let animated: Bool
}

// JSBridge处理器
class JSBridgeHandler {
    func handle<T: JSBridgeAction>(_ action: T) async throws -> T.Response {
        // 类型安全的处理
    }
}
```

#### 2.5.2 WebView性能优化
```swift
// WebView池管理
class WebViewPool {
    private var availableWebViews: [WKWebView] = []
    private let maxPoolSize = 3
    
    func dequeueWebView() -> WKWebView {
        if let webView = availableWebViews.popLast() {
            return webView
        }
        return createWebView()
    }
    
    func enqueueWebView(_ webView: WKWebView) {
        guard availableWebViews.count < maxPoolSize else { return }
        
        // 清理WebView状态
        webView.loadHTMLString("", baseURL: nil)
        availableWebViews.append(webView)
    }
    
    private func createWebView() -> WKWebView {
        let configuration = WKWebViewConfiguration()
        // 配置优化选项
        configuration.allowsInlineMediaPlayback = true
        configuration.mediaTypesRequiringUserActionForPlayback = []
        return WKWebView(frame: .zero, configuration: configuration)
    }
}
```

### 2.6 测试规范

#### 2.6.1 可测试的代码设计
```swift
// 依赖注入协议
protocol NetworkServiceProtocol {
    func request(_ endpoint: Endpoint) async throws -> Data
}

// 可测试的ViewModel
class ProductListViewModel {
    private let networkService: NetworkServiceProtocol
    @Published var products: [Product] = []
    @Published var isLoading = false
    
    // 依赖注入便于测试
    init(networkService: NetworkServiceProtocol) {
        self.networkService = networkService
    }
    
    func loadProducts() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            let data = try await networkService.request(.products)
            products = try JSONDecoder().decode([Product].self, from: data)
        } catch {
            // 错误处理
        }
    }
}

// 单元测试
class ProductListViewModelTests: XCTestCase {
    func testLoadProducts() async {
        // 使用Mock
        let mockService = MockNetworkService()
        mockService.mockData = productsJSON
        
        let viewModel = ProductListViewModel(networkService: mockService)
        await viewModel.loadProducts()
        
        XCTAssertEqual(viewModel.products.count, 3)
        XCTAssertFalse(viewModel.isLoading)
    }
}
```

### 2.7 性能优化规范

#### 2.7.1 启动优化
```swift
// AppDelegate精简
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // 仅初始化必要组件
        CrashReporter.setup()
        AppearanceManager.setup()
        
        // 延迟初始化非关键组件
        Task {
            await initializeNonCriticalServices()
        }
        
        return true
    }
    
    private func initializeNonCriticalServices() async {
        await AnalyticsService.setup()
        await PushNotificationService.setup()
        await DeepLinkHandler.setup()
    }
}
```

#### 2.7.2 列表性能优化
```swift
// 使用DiffableDataSource优化列表性能
class ProductListViewController: UIViewController {
    private var dataSource: UICollectionViewDiffableDataSource<Section, Product>!
    
    func updateProducts(_ products: [Product]) {
        var snapshot = NSDiffableDataSourceSnapshot<Section, Product>()
        snapshot.appendSections([.main])
        snapshot.appendItems(products)
        
        // 自动计算差异并更新
        dataSource.apply(snapshot, animatingDifferences: true)
    }
}

// 图片懒加载
class ProductCell: UICollectionViewCell {
    private var imageLoadingTask: Task<Void, Never>?
    
    func configure(with product: Product) {
        // 取消之前的加载任务
        imageLoadingTask?.cancel()
        
        // 异步加载图片
        imageLoadingTask = Task {
            if let image = await ImageLoader.shared.loadImage(from: product.imageURL) {
                self.imageView.image = image
            }
        }
    }
    
    override func prepareForReuse() {
        super.prepareForReuse()
        imageLoadingTask?.cancel()
        imageView.image = nil
    }
}
```

### 2.8 代码审查清单

#### 必须检查项
- [ ] 无过时API使用
- [ ] 无硬编码字符串和魔法数字
- [ ] 所有的delegate和closure使用了正确的内存管理
- [ ] 异步操作使用async/await而非回调
- [ ] 错误处理统一且完整
- [ ] 无注释代码
- [ ] 有适当的单元测试

#### 建议检查项
- [ ] 遵循单一职责原则
- [ ] 使用依赖注入
- [ ] 代码复用通过协议和泛型实现
- [ ] 性能关键路径有优化
- [ ] 有完整的文档注释

---
*文档更新日期: 2025-08-08*
*作者: Claude Code*