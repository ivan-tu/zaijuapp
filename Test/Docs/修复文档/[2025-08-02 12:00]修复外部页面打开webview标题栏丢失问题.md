# 修复外部页面打开webview标题栏丢失问题

## 问题描述
当从外部页面（如Universal Links、URL Scheme等）打开webview后，会出现标题栏丢失的情况，只能通过切换tab来重新激活标题栏显示。

## 问题原因

### 1. 导航栏隐藏逻辑
在`CFJClientH5Controller.m`的`setNavMessage`方法中，会根据URL判断是否隐藏导航栏：
```objc
BOOL shouldHide = [self isHaveNativeHeader:self.pinUrl];
[self.navigationController setNavigationBarHidden:shouldHide animated:NO];
```

### 2. 问题场景
- 从外部链接打开页面时，导航栏状态可能没有正确初始化
- 视图生命周期中`viewWillAppear`没有重新设置导航栏状态
- 切换tab时会触发`viewWillAppear`，重新设置导航栏，所以能恢复显示

## 修复方案

### 1. 在viewWillAppear中重新设置导航栏状态
```objc
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    
    // 在局Claude Code[修复标题栏]+每次页面将要显示时重新设置导航栏状态
    // 这样可以确保从外部打开或切换回来时导航栏状态正确
    dispatch_async(dispatch_get_main_queue(), ^{
        [self setNavMessage];
    });
    
    // ... 其他代码
}
```

### 2. 改进setNavMessage方法
添加日志和主线程保护：
```objc
- (void)setNavMessage {
    // 在局Claude Code[修复标题栏]+改进导航栏设置逻辑
    
    // 首先确保导航栏配置正确
    [self setUpNavWithDic:self.navDic];
    
    // 配置导航栏显示/隐藏
    BOOL shouldHide = [self isHaveNativeHeader:self.pinUrl];
    
    NSLog(@"在局Claude Code[导航栏状态]+URL: %@, shouldHide: %@", self.pinUrl, shouldHide ? @"YES" : @"NO");
    
    // 确保在主线程执行导航栏显示/隐藏操作
    if ([NSThread isMainThread]) {
        [self.navigationController setNavigationBarHidden:shouldHide animated:NO];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.navigationController setNavigationBarHidden:shouldHide animated:NO];
        });
    }
    
    // 更新状态栏样式
    [self setNeedsStatusBarAppearanceUpdate];
}
```

### 3. 监听外部链接导航通知
添加UniversalLinkNavigation通知监听：
```objc
// 在局Claude Code[修复标题栏]+监听外部链接导航通知
id universalLinkObserver = [[NSNotificationCenter defaultCenter] addObserverForName:@"UniversalLinkNavigation" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) {
    STRONG_SELF;
    if (!self) return;
    
    NSLog(@"在局Claude Code[外部链接导航]+收到UniversalLinkNavigation通知");
    
    // 延迟执行，确保视图已经完全加载
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // 重新设置导航栏状态
        [self setNavMessage];
    });
}];
```

### 4. 改进isHaveNativeHeader方法
添加更完善的判断逻辑和日志：
```objc
//判断是否隐藏原生导航栏
- (BOOL)isHaveNativeHeader:(NSString *)url{
    // 在局Claude Code[修复标题栏]+改进导航栏隐藏判断逻辑
    
    // 确保URL不为空
    if (!url || url.length == 0) {
        NSLog(@"在局Claude Code[导航栏判断]+URL为空，不隐藏导航栏");
        return NO;
    }
    
    // 获取需要隐藏导航栏的URL数组
    NSArray *hideNavURLs = [XZPackageH5 sharedInstance].ulrArray;
    if (!hideNavURLs || hideNavURLs.count == 0) {
        // 如果数组为空，默认显示导航栏
        NSLog(@"在局Claude Code[导航栏判断]+隐藏URL数组为空，显示导航栏");
        return NO;
    }
    
    BOOL shouldHide = [hideNavURLs containsObject:url];
    NSLog(@"在局Claude Code[导航栏判断]+URL: %@, 在隐藏列表中: %@", url, shouldHide ? @"YES" : @"NO");
    
    return shouldHide;
}
```

### 5. 懒加载Tab页面修复
在`XZTabBarController.m`中添加了懒加载Tab页面的视图生命周期触发：
```objc
// 在局Claude Code[Tab懒加载修复]+确保新创建的Tab页面能正确加载WebView
// 由于是懒加载的Tab页，需要手动触发视图生命周期
if (homeVC.isViewLoaded) {
    // 如果视图已经加载，直接调用viewWillAppear和viewDidAppear
    [homeVC viewWillAppear:NO];
    [homeVC viewDidAppear:NO];
} else {
    // 强制加载视图
    [homeVC view];
    // 触发生命周期方法
    [homeVC viewWillAppear:NO];
    [homeVC viewDidAppear:NO];
}
```

## 修复效果
1. 从外部链接打开页面时，导航栏会正确显示
2. 切换tab时导航栏状态保持正确
3. 添加了调试日志，方便后续排查问题
4. 代码更加健壮，处理了各种边界情况

## 相关文件
- `XZVientiane/ClientBase/BaseController/CFJClientH5Controller.m`
- `XZVientiane/XZBase/BaseController/XZTabBarController.m`